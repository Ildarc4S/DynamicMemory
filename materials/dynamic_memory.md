# Модель памяти в C++

## 📑 Оглавление

1. [Схема памяти программы](#схема-памяти-программы)
2. [Динамическое выделение памяти: new и delete](#динамическое-выделение-памяти-new-и-delete)
3. [Заполнение стека при вызове функций](#заполнение-стека-при-вызове-функций)
4. [Стек с адресами возврата](#стек-с-адресами-возврата)
5. [Раскрутка стека при завершении](#раскрутка-стека-при-завершении)
6. [Проблема утечек памяти](#проблема-утечек-памяти)
7. [Выделение памяти для двумерных массивов](#выделение-памяти-для-двумерных-массивов)
8. [Золотые правила](#золотые-правила)

---

## Схема памяти программы

В данной ниже схеме представлены названия основных областей памяти и описание хранимых элементов.

```
┌─────────────────┐ ← RAM (оперативная память)
│┌───────┐        |
││  Text │ ← Машинный код программы (read-only)
││       │   - Инструкции функций
││       │   - Константные строки
│├───────┤       |
││ Data  │ ← Глобальные и статические переменные
││       │   - Инициализированные глобальные
││       │   - Статические переменные
│├───────┤       |
││  BSS  │ ← Неинициализированные глобальные переменные (zero-initialized)
││       │   - Глобальные = 0
││       │   - Статические = 0
│├───────┤       |
││ Stack │ ← Быстрый доступ, автоматическое управление
││       │   - Локальные переменные
││       │   - Аргументы функций
││       │   - Адреса возврата
│├───────┤       |
││       │       |
││ Heap  │ ← Динамическое выделение, ручное управление
││       │   - malloc(), new, new[]
││       │   - free(), delete, delete[]
││       │       |
│└───────┘       |
│                |
└────────────────┘
```

---

## Динамическое выделение памяти: new и delete

### 📚 Что такое new и delete?

**`new`** и **`delete`** - это операторы в C++ для управления динамической памятью в **куче** (heap).

### 🔍 Основные понятия:

- **`new`** - выделяет память в куче и возвращает указатель на нее
- **`delete`** - освобождает память, выделенную через `new`
- **Куча** - область памяти, где данные живут до явного освобождения
- **Стек** - область памяти для локальных переменных (автоматическое управление)

### 🆚 Сравнение: Стек vs Куча

```cpp
// ПАМЯТЬ В СТЕКЕ (автоматическая)
void StackExample() {
  int x = 10;           // ✅ Автоматически создается
  double y = 3.14;      // ✅ Автоматически создается
  char z = 'A';         // ✅ Автоматически создается
  // ❌ Нет контроля над временем жизни
  // ✅ Автоматически удаляется при выходе из функции
}

// ПАМЯТЬ В КУЧЕ (ручное управление)
void HeapExample() {
  int* x = new int(10);     // 🎯 РУЧНОЕ создание
  double* y = new double(3.14); // 🎯 РУЧНОЕ создание
  char* z = new char('A');  // 🎯 РУЧНОЕ создание

  // ✅ Полный контроль над временем жизни
  // ❌ Нужно самостоятельно освобождать память

  delete x;  // 🎯 РУЧНОЕ удаление
  delete y;  // 🎯 РУЧНОЕ удаление
  delete z;  // 🎯 РУЧНОЕ удаление
}
```

### 🛠️ Синтаксис new и delete

#### Для одиночных переменных:
```cpp
// ВЫДЕЛЕНИЕ ПАМЯТИ
type* pointer = new type;           // Без инициализации
type* pointer = new type(value);    // С инициализацией
type* pointer = new type{value};    // Совменный стиль

// ОСВОБОЖДЕНИЕ ПАМЯТИ
delete pointer;
```

#### Для массивов:
```cpp
// ВЫДЕЛЕНИЕ ПАМЯТИ
type* array = new type[size];       // Без инициализации
type* array = new type[size]();     // Инициализация нулями
type* array = new type[size]{};     // Современный стиль
type* array = new type[size]{v1, v2, v3}; // С конкретными значениями

// ОСВОБОЖДЕНИЕ ПАМЯТИ
delete[] array;
```

### 📊 Схема работы new и delete

```
ПРОЦЕСС ВЫДЕЛЕНИЯ ПАМЯТИ:            ПРОЦЕСС ОСВОБОЖДЕНИЯ ПАМЯТИ:

1. Программа: new int(42)            1. Программа: delete ptr
   ↓                                    ↓
2. ОС: Найти свободный блок в куче   2. ОС: Пометить блок как свободный
   ↓                                    ↓
3. ОС: Вернуть адрес блока           3. Память доступна для новых выделений
   ↓
4. Указатель получает адрес
```

### 🎯 Практические примеры

#### Пример 1: Простые переменные
```cpp
#include <iostream>

int main() {
  // 📍 ВЫДЕЛЕНИЕ ПАМЯТИ
  int* number = new int(100);         // Число со значением 100
  double* price = new double{19.99};  // Цена с инициализацией
  char* symbol = new char('@');       // Символ

  // 📍 ИСПОЛЬЗОВАНИЕ
  std::cout << "Number: " << *number << std::endl;  // 100
  std::cout << "Price: " << *price << std::endl;    // 19.99
  std::cout << "Symbol: " << *symbol << std::endl;  // @

  // 📍 ОСВОБОЖДЕНИЕ ПАМЯТИ
  delete number;
  delete price;
  delete symbol;

  return 0;
}
```

#### Пример 2: Одномерные массивы
```cpp
#include <iostream>

int main() {
  int size = 5;

  // 📍 ВЫДЕЛЕНИЕ МАССИВОВ
  int* uninitialized = new int[size];        // ❌ Мусорные значения
  int* zeros = new int[size]();              // ✅ Все элементы = 0
  int* modernZeros = new int[size]{};        // ✅ Все элементы = 0
  int* initialized = new int[3]{10, 20, 30}; // ✅ Конкретные значения

  // 📍 РАБОТА С МАССИВАМИ
  for (int i = 0; i < size; i++) {
    zeros[i] = (i + 1) * 10;  // [10, 20, 30, 40, 50]
  }

  std::cout << "Array: ";
  for (int i = 0; i < size; i++) {
      std::cout << zeros[i] << " ";
  }
  std::cout << std::endl;

  // 📍 ОСВОБОЖДЕНИЕ МАССИВОВ
  delete[] uninitialized;
  delete[] zeros;
  delete[] modernZeros;
  delete[] initialized;

  return 0;
}
```

### 🗺️ Визуализация памяти

#### Сценарий 1: Одиночная переменная
```cpp
int* value = new int(42);
```

```
СТЕК:                  КУЧА:
┌─────────────────┐    ┌─────────────────┐
│ value → 0x1234 ─────→│       42        │ ← Выделенный блок
└─────────────────┘    │     0x1234      │
                       └─────────────────┘
```

#### Сценарий 2: Массив
```cpp
int* arr = new int[3]{1, 2, 3};
```

```
СТЕК:                  КУЧА:
┌─────────────────┐    ┌─────────────────┐
│ arr → 0x5678 ──────→ │ [1][2][3]       │ ← Непрерывный блок
└─────────────────┘    │    0x5678       │
                       └─────────────────┘
```

---

## Заполнение стека при вызове функций

**Стек растет СНИЗУ ВВЕРХ!**
Новые переменные добавляются выше старых.

### Пример 1: Простые переменные в стеке
```cpp
#include <iostream>

int main() {
  int a = 5;
  int b = 6;
  int c = 7;
  return 0;
}
```

**Стек при запуске программы:**
```
┌───────────┐ ← Начало стека (низкие адреса)
│ main::c=7 │
├───────────┤
│ main::b=6 │
├───────────┤
│ main::a=5 │ ← ПЕРВЫЙ добавленный элемент
└───────────┘ ← Конец стека (высокие адреса)
```

### Пример 2: Функции с параметрами
```cpp
#include <iostream>

void Calculate(int x, double y) {
  int result = x * 2;
  double total = result + y;
  std::cout << "Result: " << total << std::endl;
}

int main() {
  int num = 8;
  double value = 2.5;
  Calculate(num, value);
  return 0;
}
```

**Стек при вызове calculate(num, value):**
```
┌──────────────────────┐ ← Начало стека
│ calculate::total=18.5│ ← ПОСЛЕДНИЙ
├──────────────────────┤
│ calculate::result=16 │
├──────────────────────┤
│ calculate::y=2.5     │ ← Параметр 2
├──────────────────────┤
│ calculate::x=8       │ ← Параметр 1
├──────────────────────┤
│ main::value=2.5      │
├──────────────────────┤
│ main::num=8          │ ← ПЕРВЫЙ
└──────────────────────┘ ← Конец стека
```

---

## Стек с адресами возврата

*Теперь рассмотрим как программа "помнит" куда возвращаться после вызова функций.*

При вызове функции программа совершает прыжок к функции в памяти по ее адресу. Однако, обратно такой прыжок совершить затруднительно, так как нужно знать куда прыгать обратно. Для этого в стек сохраняются адреса возврата, с помощью них происходит возвращение из функции и продолжение выполнения кода.

### Пример 1: Вложенные вызовы функций
```cpp
#include <iostream>

void FunctionC() {
  int c = 30;
  std::cout << "Function C: " << c << std::endl;
}

void FunctionB() {
  int b = 20;
  std::cout << "Function B: " << b << std::endl;
  FunctionC();
}

void FunctionA() {
  int a = 10;
  std::cout << "Function A: " << a << std::endl;
  FunctionB();
}

int main() {
  int start = 1;
  FunctionA();
  return 0;
}
```

**Полный стек при выполнении FunctionC():**
```
┌─────────────────┐ ← Начало стека
│ FunctionC::c=30 │ ← ПОСЛЕДНИЙ
├─────────────────┤
│ адрес возврата  │ ← FunctionC → FunctionB
├─────────────────┤
│ FunctionB::b=20 │
├─────────────────┤
│ адрес возврата  │ ← FunctionB → FunctionA
├─────────────────┤
│ FunctionA::a=10 │
├─────────────────┤
│ адрес возврата  │ ← FunctionA → main
├─────────────────┤
│ main::start=1   │ ← ПЕРВЫЙ
├─────────────────┤
│ адрес возврата  │ ← main → система
└─────────────────┘ ← Конец стека
```

### Пример 2: Рекурсия с адресами возврата
```cpp
#include <iostream>

int Factorial(int n) {
  if (n <= 1) {
    return 1;
  }
  return n * Factorial(n - 1);
}

int main() {
  int number = 3;
  int result = Factorial(number);
  return 0;
}
```

**Стек при Factorial(3) в момент Factorial(1):**
```
┌─────────────────┐ ← Начало стека
│ Factorial::n=1  │ ← САМЫЙ ПОСЛЕДНИЙ вызов
├─────────────────┤
│ адрес возврата  │ ← Factorial(1) → Factorial(2)
├─────────────────┤
│ Factorial::n=2  │
├─────────────────┤
│ адрес возврата  │ ← Factorial(2) → Factorial(3)
├─────────────────┤
│ Factorial::n=3  │
├─────────────────┤
│ адрес возврата  │ ← Factorial(3) → main
├─────────────────┤
│ main::result    │
├─────────────────┤
│ main::number=3  │ ← САМЫЙ ПЕРВЫЙ вызов
├─────────────────┤
│ адрес возврата  │ ← main → система
└─────────────────┘ ← Конец стека
```

---

## Раскрутка стека при завершении

*Теперь, когда мы понимаем как заполняется стек, давайте рассмотрим как происходит его очистка при выходе из функций.*

Рассмотрим раскрутку стека при выходе из функций на примере предыдущей [программы](#пример-1-вложенные-вызовы-функций).

### Шаг 1: Завершение FunctionC() - УДАЛЯЕТСЯ ПЕРВЫМ
```
Удаляется FunctionC::c=30 и возвращаемся к FunctionB

СТАЛО:
┌─────────────────┐ ← НАЧАЛО СТЕКА
│ FunctionB::b=20 │ ← НОВАЯ ВЕРХУШКА
├─────────────────┤
│ адрес возврата  │ ← FunctionB → FunctionA
├─────────────────┤
│ FunctionA::a=10 │
├─────────────────┤
│ адрес возврата  │ ← FunctionA → main
├─────────────────┤
│ main::start=1   │
├─────────────────┤
│ адрес возврата  │ ← main → ОС
└─────────────────┘ ← КОНЕЦ СТЕКА
```

**Действие:** Удалены `c=30` и адрес возврата из FunctionC в FunctionB

### Шаг 2: Завершение FunctionB() - УДАЛЯЕТСЯ ВТОРЫМ
```
Удаляется FunctionB::b=20 и возвращаемся к FunctionA

СТАЛО:
┌─────────────────┐ ← НАЧАЛО СТЕКА
│ FunctionA::a=10 │ ← НОВАЯ ВЕРХУШКА
├─────────────────┤
│ адрес возврата  │ ← FunctionA → main
├─────────────────┤
│ main::start=1   │
├─────────────────┤
│ адрес возврата  │ ← main → ОС
└─────────────────┘ ← КОНЕЦ СТЕКА
```

**Действие:** Удалены `b=20` и адрес возврата из FunctionB в FunctionA

### Шаг 3: Завершение FunctionA() - УДАЛЯЕТСЯ ТРЕТЬИМ
```
Удаляется FunctionA::a=10 и возвращаемся к main

СТАЛО:
┌─────────────────┐ ← НАЧАЛО СТЕКА
│ main::start=1   │ ← НОВАЯ ВЕРХУШКА
├─────────────────┤
│ адрес возврата  │ ← main → ОС
└─────────────────┘ ← КОНЕЦ СТЕКА
```

**Действие:** Удалены `a=10` и адрес возврата из FunctionA в main

### Шаг 4: Завершение main() - УДАЛЯЕТСЯ ПОСЛЕДНИМ
```
Удаляется main::start=1 и выходим из программы

ПОСЛЕ:
┌─────────────────┐ ← НАЧАЛО СТЕКА
│ ПУСТО           │
└─────────────────┘ ← КОНЕЦ СТЕКА
```

**Действие:** Удалены `start=1` и адрес возврата из main в ОС

## 💡 Ключевые принципы раскрутки стека

- **LIFO (Last In, First Out)**: Последняя добавленная переменная удаляется первой
- **Автоматическое управление**: Компилятор сам генерирует код для очистки стека
- **Адреса возврата**: Удаляются вместе с локальными переменными соответствующих функций
- **Порядок удаления**: Всегда СВЕРХУ ВНИЗ, независимо от причины выхода из функции

---

## Проблема утечек памяти

*При работе с динамической памятью важно избегать утечек. Рассмотрим типичные ошибки и как их исправить.*

**`Утечка памяти`** - ситуация, когда память была выделена, но не очищена.

### Пример: Функция с утечкой памяти
```cpp
void FunctionWithLeak() {
  // 1. В стеке создается указатель
  int* dynamicArray = new int[100];

  // 2. ЗАБЫЛИ освободить память!
  // delete[] dynamicArray;  ← ЭТОЙ СТРОЧКИ НЕТ!

  // 3. Функция завершается, стек раскручивается
} // Указатель dynamicArray удаляется из стека,
  // но память в куче остается выделенной!
```

### 🎬 Пошаговый процесс утечки:

**Шаг 1: Выделение памяти**
```
СТЕК:                          КУЧА:
┌─────────────────┐           ┌─────────────────┐
│ dynamicArray  ────────────→ │[0][1][2]...[99] │ ← 100 элементов
│ (адрес 0x1234)  │           │ 0x1234          │
└─────────────────┘           └─────────────────┘
```

**Шаг 2: Выход из функции БЕЗ освобождения**
```cpp
} // Конец функции - РАСКРУТКА СТЕКА!
```

**Шаг 3: Раскрутка стека - УТЕЧКА!**
```
СТЕК ДО раскрутки:         СТЕК ПОСЛЕ раскрутки:     КУЧА:
┌─────────────────────┐    ┌─────────────────┐      ┌─────────────────┐
│ dynamicArray→0x1234 │ →  │    ПУСТО        │      │[0][1][2]...[99] │
└─────────────────────┘    └─────────────────┘      │0x1234           │
                                                    └─────────────────┘
                                                     ↑
                                                 ПАМЯТЬ ПОТЕРЯНА!
                                                 Нельзя освободить,
                                                 т.к. указатель удален
```

## ✅ ПРАВИЛЬНЫЙ вариант: Сначала очистка, потом раскрутка

### Пример: Правильное управление памятью
```cpp
void CorrectFunction() {
  // 1. В стеке создается указатель
  int* dynamicArray = new int[100];

  // 2. Указатель указывает на память в куче
  for (int i = 0; i < 100; i++) {
    dynamicArray[i] = i * 2;
  }

  // 3. ВАЖНО: Сначала освобождаем память в куче!
  delete[] dynamicArray;

  // 4. Теперь можно безопасно раскручивать стек
  // Указатель удалится, но память уже освобождена
}
```

### 🎬 Пошаговый процесс правильного управления:

**Шаг 1: Выделение памяти** (аналогично)
```
СТЕК:                          КУЧА:
┌─────────────────┐           ┌─────────────────┐
│ dynamicArray  ────────────→ │[0][1][2]...[99] │ ← 100 элементов
│ (адрес 0x1234)  │           │ 0x1234          │
└─────────────────┘           └─────────────────┘
```

**Шаг 2: Освобождение памяти ПЕРЕД выходом**
```cpp
delete[] dynamicArray;  // ОСВОБОЖДАЕМ ПАМЯТЬ!
```

**Шаг 3: Память в куче освобождена**
```
СТЕК:                          КУЧА:
┌─────────────────────┐       ┌───────────────────┐
│ dynamicArray→0x1234 │       │   ОСВОБОЖДЕНО     │
└─────────────────────┘       │(можно использовать│
                              │ для других целей) │
                              └───────────────────┘
```

**Шаг 4: Безопасная раскрутка стека**
```cpp
} // Конец функции - указатель удаляется, но утечки нет!
```

```
СТЕК ПОСЛЕ раскрутки:        КУЧА:
┌─────────────────┐          ┌─────────────────┐
│    ПУСТО        │          │    СВОБОДНА     │
└─────────────────┘          └─────────────────┘
```

## 🛠️ Практические примеры утечек и их исправление

### Пример 1: Утечка в условном операторе
```cpp
void ConditionalLeak(bool condition) {
  int* data = new int[500];

  if (condition) {
    // Может выполниться, а может нет
    delete[] data;  // Освобождаем только при condition=true
    return;
  }

  // Забыли освободить при condition=false!
  // УТЕЧКА 500 * sizeof(int) байт
}
```

**Исправление:**
```cpp
void ConditionalNoLeak(bool condition) {
  int* data = new int[500];

  if (condition) {
    delete[] data;
    return;
  }

  // ВСЕГДА освобождаем перед выходом!
  delete[] data;
}
```

### Пример 2: Неправильный оператор delete
```cpp
void WrongDelete() {
  int* data = new int[500];

  // Освободили не тем оператором, утечка!
  delete data;  // ❌ Должно быть delete[]
}
```

**Исправление:**
```cpp
void CorrectDelete() {
  int* data = new int[500];

  // Теперь освобождается массив (так же как и выделился)
  delete[] data;  // ✅ Правильно!
}
```

### Пример 3: Утечка в цикле
```cpp
void LeakingLoop() {
  for (int i = 0; i < 100; i++) {
    double* data = new double[500];  // Выделяем память
    // Работаем с data...
    // Забыли delete[] data; ← 100 утечек по 500*sizeof(double) байт
  }
}
```

**Исправление:**
```cpp
void NoLeakLoop() {
  for (int i = 0; i < 100; i++) {
    double* data = new double[500];  // Выделяем память
    delete[] data; // Освобождаем память
  }
}
```

### Пример 4: Частичная утечка
```cpp
void PartialLeak() {
  int* array1 = new int[100];
  int* array2 = new int[200];

  delete[] array1;  // Освободили первую память ✓

  array2 = array1;  // Потеряли указатель на array2!
  // Теперь нельзя освободить память array2 ← УТЕЧКА
}
```

**Исправление:**
```cpp
void NoPartialLeak() {
  int* array1 = new int[100];
  int* array2 = new int[200];

  delete[] array2; // Освободили вторую память ✓
  delete[] array1; // Освободили первую память ✓

  // Теперь можно безопасно присваивать
  array2 = array1; // Оба указателя уже освобождены
}
```

---

## Выделение памяти для двумерных массивов

### Способ 1: Прямое выделение N×M
```cpp
int main() {
  int rows = 3, cols = 4;

  // 1. Выделяем массив указателей на строки
  int** matrix = new int*[rows];

  // 2. Для каждой строки выделяем массив столбцов
  for (int i = 0; i < rows; i++) {
    matrix[i] = new int[cols];
  }

  // 3. Заполняем значениями
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      std::cin >> matrix[i][j];
    }
  }

  // 4. ОСВОБОЖДАЕМ ПАМЯТЬ в обратном порядке!
  for (int i = 0; i < rows; i++) {
      delete[] matrix[i];  // Сначала строки
  }
  delete[] matrix;         // Потом массив указателей

  return 0;
}
```

**Схема памяти:**
```
matrix → [указатель0] → [0][1][2][3]
         [указатель1] → [0][1][2][3]
         [указатель2] → [0][1][2][3]
```

### Пример: Создание и возврат матрицы из функции
```cpp
int** createMatrix(int rows, int cols) {
  int** matrix = new int*[rows];
  for (int i = 0; i < rows; i++) {
    matrix[i] = new int[cols]();  // Инициализация нулями
  }
  return matrix;
}

void freeMatrix(int** matrix, int rows) {
  for (int i = 0; i < rows; i++) {
    delete[] matrix[i];
  }
  delete[] matrix;
}

int main() {
  int rows = 2, cols = 3;

  // Создаем матрицу
  int** myMatrix = createMatrix(rows, cols);

  // Заполняем данными
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      myMatrix[i][j] = (i + 1) * (j + 1);
    }
  }

  // ОБЯЗАТЕЛЬНО освобождаем!
  freeMatrix(myMatrix, rows);

  return 0;
}
```

---

## Золотые правила

1. **Каждому `new` должен соответствовать `delete`**
2. **Каждому `new[]` должен соответствовать `delete[]`**
3. **Освобождайте память ПЕРЕД выходом из функции**
4. **Используйте `nullptr` после удаления**
5. **Проверяйте все пути выполнения функции**
